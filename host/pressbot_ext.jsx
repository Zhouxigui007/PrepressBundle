//----- POLYFILLS -----////Array & function polyfills, pulled from developer.mozilla.orgif (!Array.prototype.indexOf) {  Array.prototype.indexOf = function(searchElement, fromIndex) {    var k;    // 1. Let O be the result of calling ToObject passing    //    the this value as the argument.    if (this == null) {      throw new TypeError('"this" is null or not defined');    }    var O = Object(this);    // 2. Let lenValue be the result of calling the Get    //    internal method of O with the argument "length".    // 3. Let len be ToUint32(lenValue).    var len = O.length >>> 0;    // 4. If len is 0, return -1.    if (len === 0) {      return -1;    }    // 5. If argument fromIndex was passed let n be    //    ToInteger(fromIndex); else let n be 0.    var n = +fromIndex || 0;    if (Math.abs(n) === Infinity) {      n = 0;    }    // 6. If n >= len, return -1.    if (n >= len) {      return -1;    }    // 7. If n >= 0, then Let k be n.    // 8. Else, n<0, Let k be len - abs(n).    //    If k is less than 0, then let k be 0.    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);    // 9. Repeat, while k < len    while (k < len) {      // a. Let Pk be ToString(k).      //   This is implicit for LHS operands of the in operator      // b. Let kPresent be the result of calling the      //    HasProperty internal method of O with argument Pk.      //   This step can be combined with c      // c. If kPresent is true, then      //    i.  Let elementK be the result of calling the Get      //        internal method of O with the argument ToString(k).      //   ii.  Let same be the result of applying the      //        Strict Equality Comparison Algorithm to      //        searchElement and elementK.      //  iii.  If same is true, return k.      if (k in O && O[k] === searchElement) {        return k;      }      k++;    }    return -1;  };}if (!Array.prototype.every) {  Array.prototype.every = function(callbackfn, thisArg) {    'use strict';    var T, k;    if (this == null) {      throw new TypeError('this is null or not defined');    }    // 1. Let O be the result of calling ToObject passing the this    //    value as the argument.    var O = Object(this);    // 2. Let lenValue be the result of calling the Get internal method    //    of O with the argument "length".    // 3. Let len be ToUint32(lenValue).    var len = O.length >>> 0;    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.    if (typeof callbackfn !== 'function') {      throw new TypeError();    }    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.    if (arguments.length > 1) {      T = thisArg;    }    // 6. Let k be 0.    k = 0;    // 7. Repeat, while k < len    while (k < len) {      var kValue;      // a. Let Pk be ToString(k).      //   This is implicit for LHS operands of the in operator      // b. Let kPresent be the result of calling the HasProperty internal      //    method of O with argument Pk.      //   This step can be combined with c      // c. If kPresent is true, then      if (k in O) {        // i. Let kValue be the result of calling the Get internal method        //    of O with argument Pk.        kValue = O[k];        // ii. Let testResult be the result of calling the Call internal method        //     of callbackfn with T as the this value and argument list        //     containing kValue, k, and O.        var testResult = callbackfn.call(T, kValue, k, O);        // iii. If ToBoolean(testResult) is false, return false.        if (!testResult) {          return false;        }      }      k++;    }    return true;  };}if (!Array.prototype.some) {  Array.prototype.some = function(fun /*, thisArg*/) {    'use strict';    if (this == null) {      throw new TypeError('Array.prototype.some called on null or undefined');    }    if (typeof fun !== 'function') {      throw new TypeError();    }    var t = Object(this);    var len = t.length >>> 0;    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;    for (var i = 0; i < len; i++) {      if (i in t && fun.call(thisArg, t[i], i, t)) {        return true;      }    }    return false;  };}if (!Array.prototype.map) {  Array.prototype.map = function(callback, thisArg) {    var T, A, k;    if (this == null) {      throw new TypeError(' this is null or not defined');    }    // 1. Let O be the result of calling ToObject passing the |this|    //    value as the argument.    var O = Object(this);    // 2. Let lenValue be the result of calling the Get internal    //    method of O with the argument "length".    // 3. Let len be ToUint32(lenValue).    var len = O.length >>> 0;    // 4. If IsCallable(callback) is false, throw a TypeError exception.    // See: http://es5.github.com/#x9.11    if (typeof callback !== 'function') {      throw new TypeError(callback + ' is not a function');    }    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.    if (arguments.length > 1) {      T = thisArg;    }    // 6. Let A be a new array created as if by the expression new Array(len)    //    where Array is the standard built-in constructor with that name and    //    len is the value of len.    A = new Array(len);    // 7. Let k be 0    k = 0;    // 8. Repeat, while k < len    while (k < len) {      var kValue, mappedValue;      // a. Let Pk be ToString(k).      //   This is implicit for LHS operands of the in operator      // b. Let kPresent be the result of calling the HasProperty internal      //    method of O with argument Pk.      //   This step can be combined with c      // c. If kPresent is true, then      if (k in O) {        // i. Let kValue be the result of calling the Get internal        //    method of O with argument Pk.        kValue = O[k];        // ii. Let mappedValue be the result of calling the Call internal        //     method of callback with T as the this value and argument        //     list containing kValue, k, and O.        mappedValue = callback.call(T, kValue, k, O);        // iii. Call the DefineOwnProperty internal method of A with arguments        // Pk, Property Descriptor        // { Value: mappedValue,        //   Writable: true,        //   Enumerable: true,        //   Configurable: true },        // and false.        // In browsers that support Object.defineProperty, use the following:        // Object.defineProperty(A, k, {        //   value: mappedValue,        //   writable: true,        //   enumerable: true,        //   configurable: true        // });        // For best browser support, use the following:        A[k] = mappedValue;      }      // d. Increase k by 1.      k++;    }    // 9. return A    return A;  };}if (!Array.prototype.reduce) {  Array.prototype.reduce = function(callback /*, initialValue*/) {    'use strict';    if (this == null) {      throw new TypeError('Array.prototype.reduce called on null or undefined');    }    if (typeof callback !== 'function') {      throw new TypeError(callback + ' is not a function');    }    var t = Object(this), len = t.length >>> 0, k = 0, value;    if (arguments.length == 2) {      value = arguments[1];    } else {      while (k < len && ! k in t) {        k++;      }      if (k >= len) {        throw new TypeError('Reduce of empty array with no initial value');      }      value = t[k++];    }    for (; k < len; k++) {      if (k in t) {        value = callback(value, t[k], k, t);      }    }    return value;  };}if (!Function.prototype.bind) {  Function.prototype.bind = function(oThis) {    if (typeof this !== 'function') {      // closest thing possible to the ECMAScript 5      // internal IsCallable function      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');    }    var aArgs   = Array.prototype.slice.call(arguments, 1),        fToBind = this,        fNOP    = function() {},        fBound  = function() {          return fToBind.apply(this instanceof fNOP && oThis                 ? this                 : oThis,                 aArgs.concat(Array.prototype.slice.call(arguments)));        };    fNOP.prototype = this.prototype;    fBound.prototype = new fNOP();    return fBound;  };}//----- OBJECT CONSTRUCTORS W/PROPERTIES -----////LineItem object constructor - this object holds all finishing information for each line item.function LineItem(path, name, quantity, nesting, finishedHeight, finishedWidth, cutOffset, useDocumentArtboard, grommetStatus, grommetSpacing, grommetByNumber, pocketStatus, pocketSize, rotation, artworkObject) {    this.path = path;    this.name = name;    this.quantity = quantity;    this.nesting = nesting; //"Yes" or "No"    this.finishedHeight = finishedHeight;    this.finishedWidth = finishedWidth;    this.cutOffset = cutOffset; //array [top, bottom, left, right]    this.useDocumentArtboard = useDocumentArtboard;    this.grommetStatus = grommetStatus; //boolean    this.grommetSpacing = grommetSpacing; //array [top, bottom, left, right]    this.grommetByNumber = grommetByNumber; //array to determine if grommets are placed by number(=1) or distance(=0), array in order of [horizontal, vertical]    this.pocketStatus = pocketStatus; //boolean    this.pocketSize = pocketSize; //array [top, bottom, left, right]    this.rotation = rotation;    this.artworkObject = artworkObject; //Artwork object for this line item}//Artwork object constructor - this object references the actual artwork for the line item. Instances of these objects are created in prepFiles()function Artwork(name, artGroup, artLayer, cutPath, cutPathOffset, cutLayer, artboardPath, artboardOffset) {    this.name = name;    this.artGroup = artGroup;    this.artLayer = artLayer;    this.cutPath = cutPath;    this.cutPathOffset = cutPathOffset; //array for cut path offset [top, left]    this.cutLayer = cutLayer;    this.artboardPath = artboardPath;    this.artboardOffset = artboardOffset;}//PrintSettings object constructor - this object holds information which applies to all line itemsfunction PrintSettings(source, scale, regMarkSpacing, zundCut, materialWidth, materialHeight, rigid, perimPadding, save, closeSource, perimStroke){    this.source = source; //info from source panel, one of "active", "all", or "external"    this.scale = scale;    this.regMarkSpacing = regMarkSpacing;    this.zundCut = zundCut; //boolean - set up for Zund?    this.materialWidth = materialWidth;    this.materialHeight = materialHeight;    this.rigid = rigid; //boolean - is print material rigid?    this.perimPadding = perimPadding;    this.save = save; //boolean - will files be saved?    this.closeSource = closeSource; //boolean - close source files when finished?    this.perimStroke = perimStroke; //boolean - 1 pixel perimeter stroke?}//----- OBJECT METHODS -----////Uses LineItem.cutOffset to shrink or expand artboard. This occurs first before any other finishing is applied.//This used to use finishedHeight and finishedWidth to adjust the size, which is currently commented out.LineItem.prototype.cropArtboard = function( targetDocument, settings ){    //---- VARIABLE DECLARATION -----//    //Set artboard    var targetArtboard = targetDocument.artboards[0];    //Set scale    var inchScalePixels = 72 * (1/Number(settings.scale));    //var heightDiff = 0, widthDiff = 0;    //----- MATHS -----//        //If finishedHeight & finishedWidth is > 0, determine difference between targetDocument height & width and lineItem height & width    /*if(this.finishedHeight > 0 && this.finishedWidth > 0){        //Determine difference between finished size and artboard size        if(targetDocument.height != this.finishedHeight){            var heightDiff = (targetDocument.height - (this.finishedHeight * inchScalePixels))/2;        }        if(targetDocument.width != this.finishedWidth){            var widthDiff = (targetDocument.width - (this.finishedWidth * inchScalePixels))/2;        }    }    //If finishedHeight & finishedWidth is <= 0, reduce artboard size by that amount    if(this.finishedHeight <= 0 && this.finishedWidth <= 0){        var heightDiff = Math.abs(this.finishedHeight * inchScalePixels);        var widthDiff = Math.abs(this.finishedWidth * inchScalePixels);    }    //If cutOffset is <= 0, reduce artboard size by that amount    if(this.cutOffset <= 0){        heightDiff = Math.abs(this.cutOffset * inchScalePixels);        widthDiff = heightDiff;    }*/    //----- DO STUFF -----//    //Adjust artboard according to cutOffset sizes    targetArtboard.artboardRect = [        targetArtboard.artboardRect[0] - this.cutOffset[2] * inchScalePixels, //left        targetArtboard.artboardRect[1] + this.cutOffset[0] * inchScalePixels, //top        targetArtboard.artboardRect[2] + this.cutOffset[3] * inchScalePixels, //right        targetArtboard.artboardRect[3] - this.cutOffset[1] * inchScalePixels //bottom    ];}//Place grommets into target documentLineItem.prototype.placeGrommets = function( targetDocument, settings ){    //---- VARIABLE DECLARATION -----//    //Set artboard    var targetArtboard = targetDocument.artboards[0];    var targetLayer = targetDocument.layers.getByName("Layer 1");    //Set scale    var inchScalePixels = 72 * (1/Number(settings.scale));    //Create group for grommets    var grommetGroup = targetLayer.groupItems.add();    grommetGroup.name = "Grommets";    //Array to calculate grommet this.grommetSpacing according to scale, same indexes as this.grommetSpacing    var spacingPixels = [];    spacingPixels.length = 4;    //Array to calculate grommet distances, follows same indexes as fileObject.grommetSpacing    var grommetDistanceFromEdge = [];    grommetDistanceFromEdge.length = 4;    //Array to calculate grommet distance according to scale, same indexes as distanceFromEdge    var distanceFromEdgePixels = [];    distanceFromEdgePixels.length = 4;    //Grommet size of 1/8"    var grommetRadius  = inchScalePixels / 8;    //Grommet quantity array index: 0 = top, 1 = bottom, 2 = left, 3 = right;    var grommetNum = [];    grommetNum.length = 4;    //Grommet actual this.grommetSpacing, same index - this variable stores pixels needed to actually place the grommets evenly    var actualSpacing = []    actualSpacing.length = 4;    //----- MATHS -----//    for(var i=0;i<4;i++){        //Determine distance from the edge for the grommets        if (this.pocketSize[i] > 0 && this.pocketSize[i] < 1) {            grommetDistanceFromEdge[i] = this.pocketSize[i];        } else if (this.pocketSize[i] >= 1 && this.pocketSize[i] <= 2 || this.pocketSize[i] == 0) {            grommetDistanceFromEdge[i] = 1;        } else if (this.pocketSize[i] > 2) {            grommetDistanceFromEdge[i] = this.pocketSize[i] - .5;        }        //Set grommet spacing and distance according to scale        spacingPixels[i] = this.grommetSpacing[i] * inchScalePixels;        distanceFromEdgePixels[i] = grommetDistanceFromEdge[i] * inchScalePixels;    }    //----- DO STUFF -----//    //Determine actual grommet placement & place them onto file    for(var i = 0; i < grommetNum.length; i ++){        //----- MORE MATHS -----//        //Calculate actual grommet this.grommetSpacing in pixels        switch (i) {        //Top & bottom        case 0:        case 1:            //If user entered invalid numbers (too small or too large), avoid running math that would divide by 0            if (spacingPixels[i] <= 0 || (spacingPixels[i] > targetDocument.width && this.grommetByNumber[0] == 0)){                grommetNum[i] = 0;                actualSpacing[i] = 0;            } else {                //If user selected grommets by distance, determine number of grommets                if (this.grommetByNumber[0] == 0){                    grommetNum[i] = Math.round((targetDocument.width - (distanceFromEdgePixels[2] + distanceFromEdgePixels[3]))/(spacingPixels[i])) + 1;                //If user specified number of grommets, directly plug that number into the grommetNum variable                } else if (this.grommetByNumber[0] == 1){                    grommetNum[i] = this.grommetSpacing[i];                }                //Avoid dividing by invalid numbers                if (grommetNum[i] <= 1){                    actualSpacing[i] = 0;                } else {                    //Get the actual this.grommetSpacing needed between top & bottom grommets for this particular banner                    actualSpacing[i] = (targetDocument.width - (distanceFromEdgePixels[2] + distanceFromEdgePixels[3])) / (grommetNum[i] - 1);                }            }            break;        //Left & right        case 2:        case 3:            //If user entered invalid numbers (too small or too large), avoid running math that would divide by 0            if (spacingPixels[i] <= 0 || (spacingPixels[i] > targetDocument.height && this.grommetByNumber[1] == 0)){                grommetNum[i] = 0;                actualSpacing[i] = 0;            } else {                //If user selected grommets by distance, determine number of grommets                if (this.grommetByNumber[1] == 0){                    grommetNum[i] = Math.round((targetDocument.height - (distanceFromEdgePixels[0] + distanceFromEdgePixels[1]))/(spacingPixels[i])) + 1;                //If user specified number of grommets, directly plug that number into the grommetNum variable                } else if (this.grommetByNumber[1] == 1){                    grommetNum[i] = this.grommetSpacing[i];                }                //Avoid dividing by invalid numbers                if (grommetNum[i] <= 1){                    actualSpacing[i] = 0;                } else {                    //Get the actual this.grommetSpacing needed between left & right grommets for this particular banner                    actualSpacing[i] = (targetDocument.height - (distanceFromEdgePixels[0] + distanceFromEdgePixels[1])) / (grommetNum[i] - 1);                }            }            break;        }        //----- DO STUFF WITH MATHS -----//        //For each side, loop according to number of grommets on the side        for (var x = 0; x < grommetNum[i]; x++){            switch (i) {                //Place grommets along the top (x pos, y pos, height, width)                case 0:                var grommet = targetLayer.pathItems.ellipse(                    targetArtboard.artboardRect[1] - (distanceFromEdgePixels[0] - (inchScalePixels/16)),                    targetArtboard.artboardRect[3] + (distanceFromEdgePixels[2] - (inchScalePixels/16)) + (actualSpacing[0]*x),                    grommetRadius, grommetRadius);                break;                //Place grommets along the bottom                case 1:                var grommet = targetLayer.pathItems.ellipse(                    targetArtboard.artboardRect[0] + (distanceFromEdgePixels[1] + (inchScalePixels/16)),                    targetArtboard.artboardRect[3] + (distanceFromEdgePixels[2] - (inchScalePixels/16)) + (actualSpacing[1]*x),                    grommetRadius, grommetRadius);                break;                //Place grommets along the left                case 2:                var grommet = targetLayer.pathItems.ellipse(                    targetArtboard.artboardRect[0] + (distanceFromEdgePixels[1] + (inchScalePixels/16)) + (actualSpacing[2]*x),                    targetArtboard.artboardRect[3] + (distanceFromEdgePixels[2] - (inchScalePixels/16)),                    grommetRadius, grommetRadius);                break;                //Place grommets along the right                case 3:                var grommet = targetLayer.pathItems.ellipse(                    targetArtboard.artboardRect[0] + (distanceFromEdgePixels[1] + (inchScalePixels/16)) + (actualSpacing[3]*x),                    targetArtboard.artboardRect[2] - (distanceFromEdgePixels[3] + (inchScalePixels/16)),                    grommetRadius, grommetRadius);                break;            }            //Set appearance of each grommet            grommet.filled = true;            grommet.stroked = false;            grommet.fillColor = CMYKYellow;            grommet.fillColor.yellow = 50;            //Add each grommet to the group            grommet.move(grommetGroup, ElementPlacement.PLACEATEND);        }    }}//Add pockets to target documentLineItem.prototype.createPockets = function( targetDocument, settings ){    //---- VARIABLE DECLARATION -----//    //Set artboard    var targetArtboard = targetDocument.artboards[0];    var targetLayer = targetDocument.layers.getByName("Layer 1");    //Don't make pockets if all pocket sizes are < 0    var pocketsTrue = false;    //Array to store pocket size according to scale, follows same indexes as fileObject.pocketSize    var pocketSizePixels = [];    pocketSizePixels.length = 4;    //Scale    var inchScalePixels = 72 * (1/Number(settings.scale));    //----- MATHS -----//    //Set pocket size according to scale    for(var i=0;i<4;i++){        pocketSizePixels[i] = this.pocketSize[i] * inchScalePixels;        if(pocketSizePixels[i] > 0) pocketsTrue = true;    }    //----- DO STUFF -----//    if(pocketsTrue){        //Make artboard bigger in all directions, according to pocket size given        targetArtboard.artboardRect = [            targetArtboard.artboardRect[0] - pocketSizePixels[2],            targetArtboard.artboardRect[1] + pocketSizePixels[0],            targetArtboard.artboardRect[2] + pocketSizePixels[3],            targetArtboard.artboardRect[3] - pocketSizePixels[1]        ];        //Create black rectangle stroke around perimeter of document size (x pos, y pos, width, height)        var pocketRect = targetLayer.pathItems.rectangle(            targetArtboard.artboardRect[1],            targetArtboard.artboardRect[0],            targetDocument.width, targetDocument.height )        pocketRect.filled = false;        pocketRect.strokeColor = CMYKBlack;        pocketRect.strokeWidth = inchScalePixels / 72;        //Create Job number in top left and bottom right corners        if(pocketSizePixels[0] > 0){            var pocketLabel = targetLayer.textFrames.add();            pocketLabel.contents = this.name;            pocketLabel.textRange.characterAttributes.size = inchScalePixels / 2;            pocketLabel.textRange.characterAttributes.fillColor = CMYKYellow;            pocketLabel.textRange.characterAttributes.textFont = textFonts["MyriadPro-Bold"];            pocketLabel.textRange.paragraphAttributes.justification = Justification.LEFT;            pocketLabel.rotate(180);            if(pocketSizePixels[1] > 0) var pocketLabelBottom = pocketLabel.duplicate( targetDocument, ElementPlacement.PLACEATEND);            pocketLabel.textRange.paragraphAttributes.justification = Justification.RIGHT;            pocketLabel.position = [ pocketSizePixels[2] > 0 ? pocketSizePixels[2] : inchScalePixels*2, targetArtboard.artboardRect[1] - (inchScalePixels*.125) ];            if(pocketSizePixels[1] > 0){                pocketLabelBottom.rotate(180);                pocketLabelBottom.position = [targetDocument.width - pocketLabelBottom.width - (pocketSizePixels[3] > 0 ? pocketSizePixels[3]*2 : inchScalePixels*2), (targetArtboard.artboardRect[1] - targetDocument.height) + (inchScalePixels/1.5)];                pocketLabelBottom.textRange.paragraphAttributes.justification = Justification.RIGHT;            }        }    }}//Save target documentLineItem.prototype.saveOut = function( targetDocument, settings ){    //----- VARIABLE DECLARATIONS -----//    //Scale    var inchScalePixels = 72 * (1/Number(settings.scale));    //Set PDF settings    var saveOptions = new PDFSaveOptions();    saveOptions.pDFPreset = 'Indy Imaging PDF 01_13';    //Set layers    var targetLayerOne = targetDocument.layers.getByName("Layer 1");    var jobLabel = targetDocument.layers.getByName("Job#").textFrames[0].contents;    if(jobLabel.search("up") != -1) jobLabel += "_";    var printLabel = "";    if(settings.zundCut == true){        var targetThruCut = targetDocument.layers.getByName("Thru-cut");        targetThruCut.visible = false;        printLabel = "print";    }    var scaleLabel = "";    if(inchScalePixels<72){        scaleLabel = "_scale_";    }    //----- DO STUFF -----//    //Make destination path same as existing path    if(jobLabel){        var destFolderPrint = new Folder(this.path + "/" + jobLabel + scaleLabel + printLabel + ".pdf");        var destFolderCut = new Folder(this.path + "/" + jobLabel + scaleLabel + "cut.pdf");    } else {        var destFolderPrint = new Folder(this.path + "/" + this.name + scaleLabel + printLabel + ".pdf");        var destFolderCut = new Folder(this.path + "/" + this.name + scaleLabel + "cut.pdf");    }    var saveFile = destFolderPrint.saveDlg("Save print file");    if (saveFile) {        //If Zund is active, save both print and cut files - if not, save print file only        if (settings.zundCut == true){            targetDocument.saveAs(saveFile, saveOptions);            //Make cut layer visible and delete bottom later            targetThruCut.visible = true;            targetLayerOne.remove();            //Outline all text in document            for (var i = targetDocument.textFrames.length - 1; i > -1; i--){                targetDocument.textFrames[i].createOutline();            }            //Save cut file            saveFile = destFolderCut.saveDlg("Save cut file");            if (saveFile) targetDocument.saveAs(saveFile, saveOptions);        } else {            targetDocument.saveAs(saveFile, saveOptions);        }    }}//Rotate all artwork in fileArtwork.prototype.rotateArt = function( targetDocument ){    //----- DECLARE VARIABLES WITH MATHS -----//    var targetArtboard = targetDocument.artboards[0];    //var artboardOffsetTop = this.artGroup.top - targetArtboard.artboardRect[1];    //var artboardOffsetLeft = this.artGroup.left - targetArtboard.artboardRect[0];    var strokeDifference = (this.artGroup.visibleBounds[1] - this.artGroup.geometricBounds[1]) * 2;    //----- DO STUFF -----//    //Rotate artwork group    this.artGroup.rotate(-90);    //Rotate artboard    this.artboardPath.rotate(-90);    this.artboardPath.top = this.artGroup.top + this.artboardOffset[1];    this.artboardPath.left = this.artGroup.left + (this.artGroup.width - this.artboardPath.width + strokeDifference) - this.artboardOffset[0];    targetArtboard.artboardRect = [        this.artboardPath.geometricBounds[0],        this.artboardPath.geometricBounds[1],        this.artboardPath.geometricBounds[2],        this.artboardPath.geometricBounds[3]    ];    this.artboardOffset = [this.artGroup.top - this.artboardPath.top, this.artGroup.left - this.artboardPath.left]    //Rotate cut path group if property is defined, adjust cut path offset for copying to print file    if(this.cutPath){        this.cutPath.rotate(-90);        this.cutPath.top = this.artGroup.top + this.cutPathOffset[1];        this.cutPath.left = this.artGroup.left + (this.artGroup.width - this.cutPath.width) - this.cutPathOffset[0];        this.cutPathOffset = [this.artGroup.top - this.cutPath.top, this.artGroup.left - this.cutPath.left];    }}//----- GLOBAL VARIABLES -----////Set script directoryvar scriptPath = $.fileName.split("/");var scriptDir = scriptPath.slice(0, -1).join("/");//Set Blackvar CMYKBlack = new CMYKColor();CMYKBlack.black = 100;CMYKBlack.cyan = 0;CMYKBlack.magenta = 0;CMYKBlack.yellow = 0;//Set Yellowvar CMYKYellow = new CMYKColor();CMYKYellow.black = 0;CMYKYellow.cyan = 0;CMYKYellow.magenta = 0;CMYKYellow.yellow = 100;//Set Thru-cut colorvar CMYKThruCut = new CMYKColor();CMYKThruCut.black = 1;CMYKThruCut.cyan = 100;CMYKThruCut.magenta = 1;CMYKThruCut.yellow = 1;//Set Regmarks colorvar CMYKRegmarks = new CMYKColor();CMYKRegmarks.black = 100;CMYKRegmarks.cyan = 31;CMYKRegmarks.magenta = 31;CMYKRegmarks.yellow = 31;//Document presets to be used if Basic CMYK is not availablevar docPresets = new DocumentPreset();docPresets.units = RulerUnits.Inches;//Set up XMP API for adding metadataif (ExternalObject.AdobeXMPScript == undefined) {    ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');}//----- DO THE THING -----////processFinishing('[[{"path":"~/Desktop/testing%20files/presspot%202000%20tutorial/146213-1.pdf","name":"146213-1.pdf","quantity":2,"nesting":false,"finishedHeight":30,"finishedWidth":15,"cutOffset":[1,1,1,1],"useDocumentArtboard":false,"grommetStatus":false,"grommetSpacing":[24,24,24,24],"grommetByNumber":[0,0],"pocketStatus":false,"pocketSize":[0,0,0,0],"rotation":true}],{"source":"","scale":1,"regMarkSpacing":"36","zundCut":true,"materialWidth":"54","materialHeight":126,"rigid":false,"perimPadding":[false,false],"save":false,"closeSource":false,"perimStroke":false}]')//processFinishing('[[{"path":"/jobs/156023%20Signarama/cf/tiles/156023-3c.tif","name":"156023-3c.tif","quantity":1,"nesting":true,"finishedHeight":52,"finishedWidth":106.75,"cutOffset":-0.125,"useDocumentArtboard":false,"grommetStatus":false,"grommetSpacing":[24,24,24,24],"grommetByNumber":[0,0],"pocketStatus":false,"pocketSize":[0,0,0,0],"rotation":false},{"path":"/jobs/156023%20Signarama/cf/tiles/156023-2c.tif","name":"156023-2c.tif","quantity":1,"nesting":true,"finishedHeight":52,"finishedWidth":106.5,"cutOffset":-0.125,"useDocumentArtboard":false,"grommetStatus":false,"grommetSpacing":[24,24,24,24],"grommetByNumber":[0,0],"pocketStatus":false,"pocketSize":[0,0,0,0],"rotation":false},{"path":"/jobs/156023%20Signarama/cf/tiles/156023-1c.tif","name":"156023-1c.tif","quantity":1,"nesting":true,"finishedHeight":52,"finishedWidth":123.75,"cutOffset":-0.125,"useDocumentArtboard":false,"grommetStatus":false,"grommetSpacing":[24,24,24,24],"grommetByNumber":[0,0],"pocketStatus":false,"pocketSize":[0,0,0,0],"rotation":false}],{"source":"","scale":1,"regMarkSpacing":"36","zundCut":true,"materialWidth":"54","materialHeight":126,"rigid":false,"perimPadding":[false,false],"save":false,"closeSource":false,"perimStroke":false}]');//----- FUNCTIONS -----////Function called from PressBot Extension to populate import list from opened filesfunction getOpenFiles(){    var files = [];    for(var i=0;i<app.documents.length;i++){        files.push(app.documents[i].fullName);    }    return files.toString(); //Data for extension must be returned as string}//Function called from PressBot Extension to import filesfunction addFiles(){    var files = [];    //Only allow user to select certain files    function filter(files){        if(files.constructor.name=="Folder"){return true};        if(files.name.match(/\.pdf$/)){return true};        if(files.name.match(/\.tif$/)){return true};        if(files.name.match(/\.tiff$/)){return true};        if(files.name.match(/\.eps$/)){return true};        if(files.name.match(/\.jpg$/)){return true};        if(files.name.match(/\.psd$/)){return true};        return false;    }    //Since user can select multiple files, create an array to hold them    files = File.openDialog("Select file(s) to import: ", filter, true);    //Add each item to the importFile array and the text box    if (files){        return files.toString(); //Data for extension must be returned as string    }}//PressBot Extension sends user input from extension to this function//This sends the same objects to PresssBot as the old createUI functionfunction processFinishing(string){    var userInput, lineItems = [], settings;    //Get user input from extension as array    userInput = eval('(' + string + ')');    //Apply user input to particular variables     lineItems = userInput.shift();    settings = userInput.shift();    //Convert array of anonymous objects into LineItem instances    for(var z=0;z<lineItems.length;z++){        lineItems[z] = new LineItem(            File(lineItems[z].path),            lineItems[z].name,            lineItems[z].quantity,            lineItems[z].nesting,            lineItems[z].finishedHeight,            lineItems[z].finishedWidth,            lineItems[z].cutOffset,            lineItems[z].useDocumentArtboard,            lineItems[z].grommetStatus,            lineItems[z].grommetSpacing,            lineItems[z].grommetByNumber,            lineItems[z].pocketStatus,            lineItems[z].pocketSize,            lineItems[z].rotation,            undefined        );    }    //Make settings into PrintSettings instance too    settings = new PrintSettings(        settings.source,        settings.scale,        settings.regMarkSpacing,        settings.zundCut,        settings.materialWidth,        settings.materialHeight,        settings.rigid,        settings.perimPadding,        settings.save,        settings.closeSource,        settings.perimStroke    );    //Send finishing into to pressBot    pressBot(lineItems, settings);}//pressBot function takes an array of LineItem objects, collected from user input, uses them to call setup functionsfunction pressBot( lineItems, settings ){    //Array to contain objects which point to actual artwork for each line item    var allArtwork = [];    if(lineItems != null && settings != null){        //Run prepFiles function on each line item selected        for(var x=0; x<lineItems.length; x++){            allArtwork[x] = prepFiles( lineItems[x], settings );            lineItems[x].artworkObject = allArtwork[x];        }        //Run cutline, duplication, regmark and jobnumber functions if job is being zund-cut        //Check to make sure there are no null values in the allArtwork array, which are returned in case of an error        if (allArtwork.every(function(e){return e != null})){            printFiles( lineItems, settings );        }    }}function prepFiles( fileObject, printSettings ){    //----- LOCAL FUNCTIONS -----//    //Cut line creation function    function createCutLayer ( targetDocument ){        //----- VARIABLE DECLARATION -----//        //Variables to hold cut layer and paths        var cutLayer, cutPathGroup;        var targetArtboard = targetDocument.artboards[0];        //----- DO STUFF -----//        //Find out if there is a Thru-cut layer and assign to variable if there is        for (var i = 0; i < targetDocument.layers.length; i++){            if (targetDocument.layers[i].name == "Thru-cut"){                cutLayer = importDocument.layers.getByName("Thru-cut");            }        }        //If there is no pre-existing cut layer, create one        if(!cutLayer){            //Add cut layer            cutLayer = targetDocument.layers.add();            cutLayer.name = "Thru-cut";            cutLayer.visible = true;            //Create cut line around perimeter of artboard            var cutRect = cutLayer.pathItems.rectangle(                targetArtboard.artboardRect[1],                targetArtboard.artboardRect[0],                targetDocument.width, targetDocument.height )        } else {            cutLayer.visible = true;        }        //Group everything on cut layer together        cutPathGroup = groupArtworkOnLayer( cutLayer, "Cut Path", targetDocument );        //Make all shapes in cutGroup consistent        for (var i = 0; i < cutPathGroup.pathItems.length; i++){            cutPathGroup.pathItems[i].filled = false;            cutPathGroup.pathItems[i].stroked = true;            cutPathGroup.pathItems[i].strokeColor = CMYKThruCut;            cutPathGroup.pathItems[i].strokeWidth = (inchScalePixels*5) / 72;        }        return cutPathGroup;    }    //----- ERROR HANDLING -----//    try {        //Not sure if printSettings.source is needed any longer        //if (printSettings.source == "active" && app.documents.length == 0) throw "No file selected.";        //if (printSettings.source != "active" && !fileObject.path.exists) throw "File path is not valid.";        if (printSettings.scale < 0 || isNaN(printSettings.scale)) throw "Given scale is not a valid number.";        for(var i=0;i<4;i++){            if (isNaN(fileObject.grommetSpacing[i]) || isNaN(fileObject.pocketSize[i])) throw "Non-number values entered in grommet or pocket fields.";        }    }    catch(err) {        alert(err, "Error", true);        return null;    }    //----- VARIABLE DECLARATION -----//    //Active document and artboard    var importDocument, importArtboard;    //The actual artwork groups    var artworkGroup, cutGroup, pathForArtboard;    //Placement variable    var cutPathOffset = [], artboardOffset = [];    //Layers containing said groups    var layerOne, layerThruCut;    //Scale    var inchScalePixels = 72 * (1/Number(printSettings.scale));    //----- FILE ORGANIZATION -----//    fileObject.path = new File(fileObject.path);    //Open file, assign document and artboard variables    if(!fileObject.path.exists){ importDocument = app.documents.getByName(stripExtension(fileObject.path)); }    else { importDocument = app.open(new File(fileObject.path)); }    importArtboard = importDocument.artboards[0];    //Set origin to top left corner    importDocument.rulerOrigin = [ 0, 0 ];    //Remove extension from the file name for use on labels    fileObject.name = stripExtension( importDocument.name );    //Deselect all art on all layers, delete empty and hidden layers, unlock locked layers    for (var i = importDocument.layers.length-1; i >= 0; i--){        importDocument.layers[i].hasSelectedArtwork = false;        if (importDocument.layers[i].locked == true) { importDocument.layers[i].locked = false; }        if (importDocument.layers[i].visible == false || importDocument.layers[i].pageItems.length == 0) {             importDocument.layers[i].visible = true;            importDocument.layers[i].remove();         }    }    //Set bottom layer name to "Layer 1" and assign to variable    importDocument.layers[importDocument.layers.length-1].name = "Layer 1";    layerOne = importDocument.layers.getByName("Layer 1");    //Crop artboard to finished size, if selected in UI    if(fileObject.useDocumentArtboard == false) fileObject.cropArtboard( importDocument, printSettings );    //----- DO STUFF -----//    //Place grommets if needed    if (fileObject.grommetStatus == true){        fileObject.placeGrommets( importDocument, printSettings );    }    //Create pockets if needed    if (fileObject.pocketStatus == true){        fileObject.createPockets( importDocument, printSettings );    }    //Group all artwork onto bottom layer    artworkGroup = groupArtworkOnLayer( layerOne, "Artwork", importDocument );        var zundBleed = [0,0,0,0];    for(var x=0; x<fileObject.cutOffset.length; x++){        if(fileObject.cutOffset[x] < -.125 && fileObject.pocketStatus == false) zundBleed[x] = Math.abs(fileObject.cutOffset[x]) * inchScalePixels;    }    //Create path for artboard for rotation and copying positions    pathForArtboard = layerOne.pathItems.rectangle(        importArtboard.artboardRect[1] + zundBleed[0],        importArtboard.artboardRect[0] - zundBleed[2],        importDocument.width + zundBleed[2] + zundBleed[3], importDocument.height + zundBleed[0] + zundBleed[1] );    pathForArtboard.stroked = false;    pathForArtboard.filled = false;    //Difference between visibleBounds and geometricBounds accounts for strokes    artboardOffset.push(artworkGroup.top - pathForArtboard.top + (artworkGroup.visibleBounds[0] - artworkGroup.geometricBounds[0]));    artboardOffset.push(artworkGroup.left - pathForArtboard.left - (artworkGroup.geometricBounds[2] - artworkGroup.visibleBounds[2]));    //Create a cut layer and cut file if needed (or standardize if existing)    if(printSettings.zundCut == true){        cutGroup = createCutLayer( importDocument );        //Assign cut layer to variable        layerThruCut = importDocument.layers.getByName("Thru-cut");        //Was having trouble with files that had a stroke but also had art behind a clipping mask        //Using these variables seems to resolve it usually        var artStrokeBleedNothingHiddenTop, artStrokeBleedNothingHiddenLeft;        if(artworkGroup.top == artworkGroup.geometricBounds[1]) {            artStrokeBleedNothingHiddenTop = 0;        } else {            artStrokeBleedNothingHiddenTop = artworkGroup.visibleBounds[1] - artworkGroup.geometricBounds[1];        }        if(artworkGroup.left == artworkGroup.geometricBounds[0]) {            artStrokeBleedNothingHiddenLeft = 0;        } else {            artStrokeBleedNothingHiddenLeft = artworkGroup.geometricBounds[0] - artworkGroup.visibleBounds[0];        }                //Get cut line position for rotation and duplication purposes        //This is the same as artboardOffset with adjustments for cut path stroke        cutPathOffset.push(          //artworkGroup.top - (cutGroup.top + (cutGroup.visibleBounds[0] - cutGroup.geometricBounds[0])) + (artworkGroup.visibleBounds[0] - artworkGroup.geometricBounds[0])            artworkGroup.top - (cutGroup.top + (cutGroup.visibleBounds[0] - cutGroup.geometricBounds[0])) - artStrokeBleedNothingHiddenTop        );        cutPathOffset.push(          //artworkGroup.left - (cutGroup.left - (cutGroup.geometricBounds[2] - cutGroup.visibleBounds[2])) - (artworkGroup.geometricBounds[2] - artworkGroup.visibleBounds[2])            artworkGroup.left - (cutGroup.left - (cutGroup.geometricBounds[2] - cutGroup.visibleBounds[2])) + artStrokeBleedNothingHiddenLeft        );    }   //Artwork constructor (name, artGroup, artLayer, cutPath, cutPathOffset, cutLayer, artboardPath, artboardOffset)    var artworkObject = new Artwork(        fileObject.name,        artworkGroup,        layerOne,        cutGroup,        cutPathOffset,        layerThruCut,        pathForArtboard,        artboardOffset    )    //Rotate artwork object if needed    if (fileObject.rotation == true){        artworkObject.rotateArt( importDocument );    }    if (printSettings.save == true && printSettings.zundCut == false){        fileObject.saveOut( importDocument, printSettings );    }    return artworkObject;}function printFiles( fileObjects, printSettings ){    //----- LOCAL FUNCTIONS -----//    //Regmarks creation function    function placeRegMarks ( targetDocument, printSettings ){        var targetArtboard = targetDocument.artboards[0];        //Scale        var inchScalePixels = 72 * (1/Number(printSettings.scale));        //RegMark size of 1/4"        var regMarkRadius = inchScalePixels / 4;        //Make RegMarks 36" apart        var regMarkSpacing = Number(printSettings.regMarkSpacing) * inchScalePixels;        //Padding distance is 1"... User will be able to set this later        var paddingTopBottom, paddingLeftRight;        printSettings.perimPadding[0] == true ? paddingTopBottom = .5 : paddingTopBottom = 1;        printSettings.perimPadding[1] == true ? paddingLeftRight = .5 : paddingLeftRight = 1;        //Make artboard 1" or .5" bigger for RegMarks        targetArtboard.artboardRect = [            targetArtboard.artboardRect[0] - (inchScalePixels * paddingLeftRight),            targetArtboard.artboardRect[1] + (inchScalePixels * paddingTopBottom),            targetArtboard.artboardRect[2] + (inchScalePixels * paddingLeftRight),            targetArtboard.artboardRect[3] - (inchScalePixels * paddingTopBottom)        ];        //Create Regmarks layer        var regLayer = targetDocument.layers.add();        regLayer.name = "Regmarks";        //Determine number of RegMarks for all sides        var regMarkWidthNum = Math.round((targetDocument.width - (inchScalePixels * paddingLeftRight)) / regMarkSpacing);        var regMarkHeightNum = Math.round((targetDocument.height - (inchScalePixels * paddingTopBottom)) / regMarkSpacing);        var regMarkWidthDistance = (targetDocument.width - (inchScalePixels * paddingLeftRight)) / regMarkWidthNum;        var regMarkHeightDistance = (targetDocument.height - (inchScalePixels * paddingTopBottom))/regMarkHeightNum;        if (regMarkWidthNum == 0){            regMarkWidthNum = 1;        }        if (regMarkHeightNum == 0){            regMarkHeightNum = 1;        }        //Loop to set Regmarks evenly spaced along the top        for (var i = 0; i <= regMarkWidthNum; i++) {            var regMark = regLayer.pathItems.ellipse(                targetArtboard.artboardRect[1] - ((inchScalePixels * (paddingTopBottom/2)) - (inchScalePixels / 8)),                targetArtboard.artboardRect[0] + ((inchScalePixels * (paddingLeftRight/2)) - (inchScalePixels / 8)) + (regMarkWidthDistance*i),                regMarkRadius, regMarkRadius);            regMark.filled = true;            regMark.stroked = false;            regMark.fillColor = CMYKRegmarks;        }        //Loop to set Regmarks evenly this.grommetSpacing along the bottom        for (var i = 0; i <= regMarkWidthNum; i++) {            var regMark = regLayer.pathItems.ellipse(                targetArtboard.artboardRect[3] + ((inchScalePixels * (paddingTopBottom/2)) + (inchScalePixels / 8)),                targetArtboard.artboardRect[0] + ((inchScalePixels * (paddingLeftRight/2)) - (inchScalePixels / 8)) + (regMarkWidthDistance*i),                regMarkRadius, regMarkRadius);            regMark.filled = true;            regMark.stroked = false;            regMark.fillColor = CMYKRegmarks;        }        //Loop to set Regmarks evenly this.grommetSpacing along the left side        for (var i = 1; i < regMarkHeightNum; i++) {            var regMark = regLayer.pathItems.ellipse(                targetArtboard.artboardRect[3] + ((inchScalePixels * (paddingTopBottom/2)) + (inchScalePixels / 8)) + (regMarkHeightDistance*i),                targetArtboard.artboardRect[0] + ((inchScalePixels * (paddingLeftRight/2)) - (inchScalePixels / 8)),                regMarkRadius, regMarkRadius);            regMark.filled = true;            regMark.stroked = false;            regMark.fillColor = CMYKRegmarks;        }        //Loop to set Regmarks evenly this.grommetSpacing along the right side        for (var i = 1; i < regMarkHeightNum; i++) {            var regMark = regLayer.pathItems.ellipse(                targetArtboard.artboardRect[3] + ((inchScalePixels * (paddingTopBottom/2)) + (inchScalePixels / 8)) + (regMarkHeightDistance*i),                targetArtboard.artboardRect[2] - ((inchScalePixels * (paddingLeftRight/2)) + (inchScalePixels / 8)),                regMarkRadius, regMarkRadius);            regMark.filled = true;            regMark.stroked = false;            regMark.fillColor = CMYKRegmarks;        }    }    //Job# layer creation function    function createJobLayer ( jobName, targetDocument, printSettings ){        var targetArtboard = targetDocument.artboards[0];        //Scale        var inchScalePixels = 72 * (1/Number(printSettings.scale));        var labelEdgeOffset = []; //bottom, right        printSettings.perimPadding[0] == true ? labelEdgeOffset[0] = .0625 : labelEdgeOffset[0] = .25;        printSettings.perimPadding[1] == true ? labelEdgeOffset[1] = .5 : labelEdgeOffset[1] = 1;        labelEdgeOffset[1] += 2.125 //Additional tab offset        //Create Job# layer        var jobLayer = targetDocument.layers.add();        jobLayer.name = "Job#";        //Create Job# in bottom right corner        var printLabel = targetDocument.textFrames.add();        printLabel.contents = jobName;        printLabel.textRange.characterAttributes.size = inchScalePixels / 3;        printLabel.textRange.characterAttributes.fillColor = CMYKBlack;        printLabel.textRange.characterAttributes.textFont = textFonts["MyriadPro-Bold"];        printLabel.textRange.paragraphAttributes.justification = Justification.RIGHT;        printLabel.position = [            (targetArtboard.artboardRect[2] - (printLabel.anchor[0] - printLabel.position[0])) - (inchScalePixels*labelEdgeOffset[1]),            (targetArtboard.artboardRect[3] + (printLabel.position[1] - printLabel.anchor[1])) + (inchScalePixels*labelEdgeOffset[0])        ];        //Copy it to top right corner        var printLabelTop = printLabel.duplicate();        printLabelTop.textRange.paragraphAttributes.justification = Justification.LEFT;        printLabelTop.rotate(180);        printLabelTop.position = [            (targetArtboard.artboardRect[2] - printLabelTop.width) - (inchScalePixels*labelEdgeOffset[1]),            (targetArtboard.artboardRect[1] - (printLabelTop.anchor[1] - printLabelTop.position[1]) - (inchScalePixels*labelEdgeOffset[0]))        ];    }        //Black stroke around art (mostly for double-sides)    function createPerimeterStroke ( targetDocument, printSettings){        var targetArtboard = targetDocument.artboards[0];        var targetLayer = targetDocument.layers.getByName("Layer 1");        var cutLayer = targetDocument.layers.getByName("Thru-cut");        //Scale        var inchScalePixels = 72 * (1/Number(printSettings.scale));                var pocketRect = targetLayer.pathItems.rectangle(            targetArtboard.artboardRect[1],            targetArtboard.artboardRect[0],            targetDocument.width, targetDocument.height )        pocketRect.filled = false;        pocketRect.strokeColor = CMYKBlack;        pocketRect.strokeWidth = inchScalePixels / 72;    }    //Nesting function    function nestArtwork( targetDocument, nestingObjects, printSettings ){        //----- VARIABLE DECLARATION -----//        var targetArtboard = targetDocument.artboards[0];        var targetLayerOne = targetDocument.layers.getByName("Layer 1");        var targetThruCut = targetDocument.layers.add();        targetThruCut.name = "Thru-cut";        targetThruCut.visible = true;        //Scale        var inchScalePixels = 72 * (1/Number(printSettings.scale));        //Object to store in global metadata as job is being created        var lineItem = {};        //Variable to return files that don't fit, to be re-nested in new file        var returnFiles = [], nestingOrder = [];        //Keep note of how many files were nested        var numberNested = [];        //Keep note of files that are too large for material altogether        var failed = "";        //Rows array holds the position on each row to place the artwork        var rows = [];        rows.push([0, 0]); //[left, top]        //Cols array holds column of rows for stacking vertically        var cols = [];        cols.push([0,0]);        //Group to collect individual artboards from nested files, then resize actual artboard to it        artboardGroup = targetLayerOne.groupItems.add();        //Space between nested files        var padding;        //Set padding dependent on if it's being cut on the Zund or not        printSettings.zundCut == true ? padding = 0.5 * inchScalePixels : padding = 0;        //Set perimter padding according to user selection        var perimPaddingTopBottom, perimPaddingLeftRight;        printSettings.perimPadding[0] == true ? perimPaddingTopBottom = .5 : perimPaddingTopBottom = 1;        printSettings.perimPadding[1] == true ? perimPaddingLeftRight = .5 : perimPaddingLeftRight = 1;        //Variables to be set in the loop for each file being nested        var artHeight, artWidth, artwork, nestedArtwork, nestedCutPath, nestedArtboard, artboardGroup, jobLabel;        //This variable offsets the insertion point according to the size of the file        //Using the actual 0,0 point of the document often ends up nesting files off the canvas altogether        var overallOffset;        //Functional size is the maximum size that the art will be nested in        //To start, set at 1" less than material size on all sides to allow for regmarks, etc        var functionalWidth = (printSettings.materialWidth * inchScalePixels) - (inchScalePixels * perimPaddingLeftRight * 2);        var functionalHeight = (printSettings.materialHeight * inchScalePixels) - (inchScalePixels * perimPaddingTopBottom * 2);        //----- FILE ORGANIZATION -----//        //Organize files by size to pass them through the nesting loop by size        if(nestingObjects.length>1){            //Map index, area and height to temporary array            var nestingMap = nestingObjects.map( function(obj, i) {                return { index: i, name: obj.name, area: obj.artworkObject.artboardPath.area, height: obj.artworkObject.artboardPath.height };            });            //First sort temp array in ascending order numerically            /*nestingMap.sort(function(a, b) {                return Number(a.name.split("-")[1].match(/\d/)) - Number(b.name.split("-")[1].match(/\d/));            });*/            //This will sort objects by size in decending order, and in numerically ascending order if the size is equal            nestingMap.sort( function(a,b) {                if(a.area === b.area){                    return Number(a.name.split("-")[1].match(/\d/)) - Number(b.name.split("-")[1].match(/\d/));                } else {                    return b.area - a.area;                }            });            //Create new variable to hold full objects, reordered by area            nestingOrder = nestingMap.map( function(e){                return nestingObjects[e.index];            });            //Determine maximum height, either 124" or the tallest file other than that            var nestingLongest = nestingMap.reduce( function(a,b) {                return (a.height > b.height ? a : b);            }, printSettings);            //If longest file is larger than functionalHeight but will still fit on PDF and is on a roll, set it to longest file            if(printSettings.rigid == false && functionalHeight < nestingLongest.height && nestingLongest.height < (198 * 72)){ functionalHeight = nestingLongest.height; }        //If there is only one file in array, skip reordering        } else if (nestingObjects.length == 1){            nestingOrder.push(nestingObjects[0]);            //If longest file is larger than functionalHeight but will still fit on PDF and is on a roll, set it to longest file            if (printSettings.rigid == false && functionalHeight < nestingObjects[0].artworkObject.artboardPath.height && nestingObjects[0].artworkObject.artboardPath.height < (198 * 72)){                functionalHeight = nestingObjects[0].artworkObject.artboardPath.height;            }        }        //----- ART PLACEMENT LOOP -----//        //Cycle through array which contains each line item in order of size        for(var i=0; i<nestingOrder.length; i++){                        //----- SET VARIABLES FOR EACH FILE -----//                        numberNested[i] = 0;            artHeight = nestingOrder[i].artworkObject.artboardPath.height;            artWidth = nestingOrder[i].artworkObject.artboardPath.width;            artwork = nestingOrder[i].artworkObject;            lineItem = {name:"",quantity:0};            //On first iteration, set offset variables            if(i==0) {                //overallOffset centers art on canvas (more or less)                overallOffset = [artWidth, artHeight/2];                //placementOffset places nested artwork relative to first line item nested                //This is needed for files with elemets within and beyond the clipping mask bounds                placementOffset = [artwork.artboardOffset[0], artwork.artboardOffset[1]];            }            //If file is too large for the material, note it and skip to next iteration            if (artHeight > functionalHeight || artWidth > functionalWidth) {                failed += nestingOrder[i].name + "\n";                numberNested.splice(i, 1);                continue;            }            lineItem.name = nestingOrder[i].name;            //----- PLACE THE FILE FOR REALS -----//            //For total quantity of each line item...            for(var x=1; x<=nestingOrder[i].quantity; x++){                //On roll, test if artwork can be placed on any existing rows, starting from bottom                if(printSettings.rigid == false){                    for(var z=0; z<rows.length; z++){                        //Cycle through each row until there is one with enough space within the maximum material size                        if (artWidth + Math.abs(rows[z][0]) <= functionalWidth && artHeight + Math.abs(rows[z][1]) <= functionalHeight){                            //Copy artwork, cutpath (if needed) and artboard reference into new document                            nestedArtwork = artwork.artGroup.duplicate( targetLayerOne );                            if(printSettings.zundCut == true) nestedCutPath = artwork.cutPath.duplicate( targetThruCut );                            nestedArtboard = artwork.artboardPath.duplicate( targetLayerOne );                            //Move artwork, cutpath (if needed) and artboard reference into position as determined by the insertion point of the current row                            //.position array is [left, top], *offset arrays are [top, left] - I know, I know, and I'm sorry                            if(rows[z] == [0, 0]) { nestedArtwork.position = [                                (rows[z][0] - artWidth) + overallOffset[0],                                (rows[z][1] + artHeight) - overallOffset[1]                            ];                            //After artwork for first item is placed, offset all other items relative to the first item                            } else { nestedArtwork.position = [                                (rows[z][0] - artWidth - placementOffset[1] + artwork.artboardOffset[1]) + overallOffset[0],                                (rows[z][1] + artHeight + artwork.artboardOffset[0] - placementOffset[0]) - overallOffset[1]                            ];}                            if(printSettings.zundCut == true) nestedCutPath.position = [nestedArtwork.position[0] - artwork.cutPathOffset[1], nestedArtwork.position[1] - artwork.cutPathOffset[0]];                            nestedArtboard.position = [nestedArtwork.position[0] - artwork.artboardOffset[1], nestedArtwork.position[1] - artwork.artboardOffset[0]];                            //Add artboard reference into the artboard group                            nestedArtboard.move(artboardGroup, ElementPlacement.PLACEATEND);                            //Move the insertion point for the current row to the left of the placed file                            rows[z] = [rows[z][0] - artWidth - padding, rows[z][1]];                            //If loop is on the top row, add another row for potential files                            if (z+1==rows.length){ rows[z+1] = [0, rows[z][1] + artHeight + padding]; }                            numberNested[i] += 1;                            lineItem.quantity += 1;                            //With art placed, break out of loop so it doesn't keep adding rows forever                            break;                        //If artwork has cycled through all rows and won't fit, adjust quantity and add it to files being returned                        } else if (z+1==rows.length){                            nestingOrder[i].quantity = nestingOrder[i].quantity - numberNested[i];                            returnFiles.push(nestingOrder[i]);                            x = nestingOrder[i].quantity;                            break;                        }                    }                //On rigid material, arrange in columns, so it populates vertically                } else {                    for(var z=0; z<cols.length; z++){                        //Cycle through each row until there is one with enough space within the maximum material size                        if (artWidth + Math.abs(cols[z][0]) <= functionalWidth && artHeight + Math.abs(cols[z][1]) <= functionalHeight){                            //Copy artwork, cutpath (if needed) and artboard reference into new document                            nestedArtwork = artwork.artGroup.duplicate( targetLayerOne );                            if(printSettings.zundCut == true) nestedCutPath = artwork.cutPath.duplicate( targetThruCut );                            nestedArtboard = artwork.artboardPath.duplicate( targetLayerOne );                            //Move artwork, cutpath (if needed) and artboard reference into position as determined by the insertion point of the current row                            //.position array is [left, top], *offset arrays are [top, left] - I know, I know, and I'm sorry                            if(cols[z] == [0, 0]) { nestedArtwork.position = [                                (cols[z][0] - artWidth) + overallOffset[0],                                (cols[z][1] + artHeight) - overallOffset[1]                            ];                            //After artwork for first item is placed, offset all other items relative to the first item                            } else { nestedArtwork.position = [                                (cols[z][0] - artWidth - placementOffset[1] + artwork.artboardOffset[1]) + overallOffset[0],                                (cols[z][1] + artHeight + artwork.artboardOffset[0] - placementOffset[0]) - overallOffset[1]                            ];}                            if(printSettings.zundCut == true) nestedCutPath.position = [nestedArtwork.position[0] - artwork.cutPathOffset[1], nestedArtwork.position[1] - artwork.cutPathOffset[0]];                            nestedArtboard.position = [nestedArtwork.position[0] - artwork.artboardOffset[1], nestedArtwork.position[1] - artwork.artboardOffset[0]];                            //Add artboard reference into the artboard group                            nestedArtboard.move(artboardGroup, ElementPlacement.PLACEATEND);                            //If loop is on the last column, add another column to the left for potential files                            if (z+1==cols.length){ cols[z+1] = [cols[z][0] - artWidth - padding, cols[z][1]]; }                            //Move the insertion point for the current column to the top of the placed file                            cols[z] = [cols[z][0], cols[z][1] + artHeight + padding];                            numberNested[i] += 1;                            lineItem.quantity += 1;                            //With art placed, break out of loop so it doesn't keep adding rows forever                            break;                        //If artwork has cycled through all rows and won't fit, adjust quantity and add it to files being returned                        } else if (z+1==cols.length){                            nestingOrder[i].quantity = nestingOrder[i].quantity - numberNested[i];                            returnFiles.push(nestingOrder[i]);                            x = nestingOrder[i].quantity;                            break;                        }                    }                }            }            metaData.push(lineItem);                    }        //Alert user of any files that were too large        if(failed != ""){            alert("The following file(s) were too large to be nested: \n" + failed);        }        //If at least 1 file was sucessfully nested, prep file for finishing functions        if(numberNested.length > 0){            //Center artboard and all artwork within the drawing area            //First group everything on art layer and cut layer (except the artboardGroup)            var printGroup = groupArtworkOnLayer( targetLayerOne, "Print Group", targetDocument );            var cutGroup = groupArtworkOnLayer( targetThruCut, "Cut Group", targetDocument );            artboardGroup.move(targetLayerOne, ElementPlacement.PLACEATEND);            //Determine offsets            var printGroupOffsetLeft = printGroup.left - artboardGroup.left;            var printGroupOffsetTop = printGroup.top - artboardGroup.top;            var cutGroupOffsetLeft = cutGroup.left - artboardGroup.left;            var cutGroupOffsetTop = cutGroup.top - artboardGroup.top;            //Center artboard            artboardGroup.left = artboardGroup.width/-2;            artboardGroup.top = artboardGroup.height/2;            //Set artboard to size of artwork            artboardGroup.selected = true;            targetDocument.fitArtboardToSelectedArt(0);            artboardGroup.remove();            //Move artwork and cut groups to new artboard location, relative to their offsets            printGroup.left = targetDocument.artboards[0].artboardRect[0] + printGroupOffsetLeft;            printGroup.top = targetDocument.artboards[0].artboardRect[1] + printGroupOffsetTop;            cutGroup.left = targetDocument.artboards[0].artboardRect[0] + cutGroupOffsetLeft;            cutGroup.top = targetDocument.artboards[0].artboardRect[1] + cutGroupOffsetTop;            //Determine regmark spacing based on number of rows or columns            //Currently having user do this            /*var reg;            if(rows.length > 1) {                reg = Math.round((targetDocument.height / (rows.length - 1)) / inchScalePixels);                if (reg < 36) printSettings.regMarkSpacing = reg;            }            if(cols.length > 1) {                reg = Math.round((targetDocument.width / (cols.length - 1)) / inchScalePixels);                if (reg < 36) printSettings.regMarkSpacing = reg;            }*/            numberNested = [];            return returnFiles;        } else { return null; }    }    //----- ERROR HANDLING -----//    //Make sure Print.ai preset is present    try {        if (!app.startupPresetsList.some(function(e){return e == "Print"})) throw "\'Print.ai\' preset not found.";    }    catch(err) {        alert(err, "Error", true);        return;    }    //----- VARIABLE DECLARATION -----//    var printDocument, printArtboard, printLayerOne, printThruCut;    var nestingFiles = [], printFile = [];    var nestingDocument, nestingArtboard, nestingLayerOne, nestingThruCut;    //Scale    var inchScalePixels = printSettings.scale;    //Info to send to XMPMeta object    var metaData = [], jobLabel, otherLines = "";    //Create XMPMeta object to add metadata to file    var xmpTarget;    //----- DO STUFF -----//    //Cycle through all files, separating nested from non-nesting files    for(var x=0; x<fileObjects.length; x++){                //----- NOT NESTING -----//                //If the current file is not being nested, send through nesting function all by its lonesome        if(fileObjects[x].nesting == false){            //nestArtwork function requires an array, place art info into one            printFile.push(fileObjects[x]);            //Create a new document for each un-nested file            while(printFile != null && printFile.length > 0){                printDocument = app.documents.addDocument("Print");                //Assign XMPMeta object to add metadata to file                xmpTarget = new XMPMeta(printDocument.XMPString);                //Nest artwork into new document                printFile = nestArtwork( printDocument, printFile, printSettings );                if(printFile != null){                    //Create regmarks and job layer, save out                    if(printSettings.zundCut == true){                        placeRegMarks( printDocument, printSettings );                        if(metaData[x].quantity > 1){                            qtyUpLabel = "_" + metaData[x].quantity + "up";                        } else {                            qtyUpLabel = "";                        }                        createJobLayer( fileObjects[x].name + qtyUpLabel, printDocument, printSettings );                    }                    if(printSettings.perimStroke) createPerimeterStroke( printDocument, printSettings );                    //Add metatags                    xmpTarget.setProperty(XMPConst.NS_XMP, "PrintType", "Print");                    xmpTarget.setProperty(XMPConst.NS_XMP, "DocumentHeight", Math.round((printDocument.height/72) * 100) / 100);                    xmpTarget.setProperty(XMPConst.NS_XMP, "DocumentWidth", Math.round((printDocument.width/72) * 100) / 100);                    xmpTarget.setProperty(XMPConst.NS_XMP, "LineItem", metaData[x].name);                    xmpTarget.setProperty(XMPConst.NS_XMP, "QuantityUp", metaData[x].quantity);                    xmpTarget.setProperty(XMPConst.NS_XMP, "OtherLineItems", " ");                    xmpTarget.setProperty(XMPConst.NS_XMP, "CutType", "Thru Cut");                    xmpTarget.setProperty(XMPConst.NS_XMP, "Scale", inchScalePixels);                    //xmpTarget.setProperty(XMPConst.NS_XMP, "CreatedBy", "Nathan Beck");                    printDocument.XMPString = xmpTarget.serialize(XMPConst.SERIALIZE_USE_COMPACT_FORMAT);                    if(printSettings.save) fileObjects[x].saveOut( printDocument, printSettings );                }                //If printFile returned null because nothing was nested, close                if(printFile == null && printSettings.closeSource) printDocument.close(SaveOptions.DONOTSAVECHANGES);            }            //Empty printFile array            printFile = [];        } else if(fileObjects[x].nesting == true){            //Extract files to be nested            nestingFiles.push(fileObjects[x]);        }    }    //----- NESTING -----//    //Nest files together    while (nestingFiles != null && nestingFiles.length > 0){        //Set file name and save location to first element in nestingFiles (organize this later)        var nestingJobName = nestingFiles[0].name;        var nestingJobPath = nestingFiles[0].path;        //Bind LineItem's saveOut function to name and path determined above        var nestSave = nestingFiles[0].saveOut.bind( nestingFiles[0] );        var qtyUpLabel = "";        //Create new document for nesting        nestingDocument = app.documents.addDocument("Print");        //Assign XMPMeta object to add metadata to file        xmpTarget = new XMPMeta(nestingDocument.XMPString);        //Nest!        nestingFiles = nestArtwork( nestingDocument, nestingFiles, printSettings );        //Once all files have been nested, add regmarks and job layer, save out        if(nestingFiles != null){            //Determine lowest line item number for job label            jobLabel = metaData.reduce( function(a,b) {                return (Number(a.name.split("-")[1].match(/\d/)) < Number(b.name.split("-")[1].match(/\d/)) ? a : b);            }).name;            //List other line items in file            for(var m=0;m<metaData.length;m++){                if (metaData[m].name != jobLabel) otherLines += "-" + metaData[m].name.split("-")[1] + " ";            }            if(printSettings.zundCut == true){                //Place RegMarks and Job# layers                placeRegMarks( nestingDocument, printSettings );                if(metaData.length == 1 && metaData[0].quantity > 1) qtyUpLabel = "_" + metaData[0].quantity + "up";                createJobLayer( jobLabel + qtyUpLabel, nestingDocument, printSettings );            }            if(printSettings.perimStroke) createPerimeterStroke( nestingDocument, printSettings );            //Add metatags            xmpTarget.setProperty(XMPConst.NS_XMP, "PrintType", "Print");            xmpTarget.setProperty(XMPConst.NS_XMP, "DocumentHeight", Math.round((nestingDocument.height/72) * 100) / 100);            xmpTarget.setProperty(XMPConst.NS_XMP, "DocumentWidth", Math.round((nestingDocument.width/72) * 100) / 100);            xmpTarget.setProperty(XMPConst.NS_XMP, "LineItem", jobLabel);            if (metaData.length > 1){                xmpTarget.setProperty(XMPConst.NS_XMP, "QuantityUp", 1);            } else {                xmpTarget.setProperty(XMPConst.NS_XMP, "QuantityUp", metaData[0].quantity);            }            xmpTarget.setProperty(XMPConst.NS_XMP, "OtherLineItems", otherLines);            xmpTarget.setProperty(XMPConst.NS_XMP, "CutType", "Thru Cut");            xmpTarget.setProperty(XMPConst.NS_XMP, "Scale", inchScalePixels);            //xmpTarget.setProperty(XMPConst.NS_XMP, "CreatedBy", "Nathan Beck");            nestingDocument.XMPString = xmpTarget.serialize(XMPConst.SERIALIZE_USE_COMPACT_FORMAT);            if(printSettings.save) nestSave( nestingDocument, printSettings );        }    }    //If nestArtwork returned null because nothing was nested, close    if(nestingFiles == null) nestingDocument.close(SaveOptions.DONOTSAVECHANGES);    //Close all source files    if(printSettings.closeSource){        for(var z=fileObjects.length-1; z>=0; z--){            for(var n = app.documents.length-1; n>=0; n--) {                if(app.documents[n].name == fileObjects[z].path.name) app.documents[n].close(SaveOptions.DONOTSAVECHANGES);            }        }    }}//Place all artwork on a specified layer into a groupfunction groupArtworkOnLayer( layer, groupName, targetDocument ){    //Remove hidden items, unlock locked items    for (var i=layer.pageItems.length-1; i>=0; i--){        layer.pageItems[i].locked = false;        if (layer.pageItems[i].hidden == true){            layer.pageItems[i].remove();        }    }    //Remove guides    for (var x=layer.pathItems.length-1; x>=0; x--){        if (layer.pathItems[x].guides == true){            layer.pathItems[x].remove();        }    }    //Select all artwork on selected layer    layer.hasSelectedArtwork = true;    var activeSelection = targetDocument.selection;    //Create a group for the selected artwork to go into    var artwork = layer.groupItems.add();    artwork.name = groupName;    //Move selected art into group on layer and then deselect it    for (var z=0; z < activeSelection.length; z++){        activeSelection[z].move(artwork, ElementPlacement.PLACEATEND);        activeSelection[z].selected = false;    }    layer.hasSelectedArtwork = false;    return artwork;}//Function strips extension, path directory & _* from the document name//This is like the most useful function I've made so farfunction stripExtension( docName ){    var fileName = docName.toString();    var pos = fileName.lastIndexOf(".");    var slashpos = fileName.lastIndexOf("/");    var scorepos = fileName.lastIndexOf("_");    if(pos != -1){ fileName = fileName.substring(pos, -1); }    if(slashpos != -1){ fileName = fileName.substring(slashpos+1); }    if(scorepos != -1){ fileName = fileName.substring(scorepos, -1); }    return fileName;}